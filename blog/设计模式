### 装饰者模式
* 把class A对象，传递给class B的对象；在class B的方法里，修改A对象；实现A对象的功能扩展。
* 添加若干个这种class B，并传参A对象，就是添加装饰的过程
 
### 单例模式
* 确保某个class，只创建一个对象
* 懒汉式：    第一次使用的时候实例化对象
* 饿汉式：    class实例化的时候，实例化对象

### 适配器模式
* 加一个适配器类C，最终目的是，调用C的接口，实现兼容
* 举个例子，Apple跟Android的线不兼容，但是加一个转接头就行
* 搜到的几个例子，差异很大

### 模板模式
* 抽象类定义执行流程
* 子类实现抽象方法，控制流程中步骤的具体实现方式
 
### 工厂模式
> 为什么要工厂？ 给工厂指定参数，比每次给产品指定参数，要方便
* 简单工厂 
    * 一个抽象类或者接口，表示抽象产品；
    * 不同的实现，表示不同的产品
    * 一个工厂类，传参不同参数，返回不同的具体产品
* 工厂方法模式
    * 
* 抽象工厂
    * 产品是抽象类，工厂也是抽象类
    * 不同的工厂的实现类，各自只支持一种产品
可以参考 [CSDN博客](https://blog.csdn.net/wyxhd2008/article/details/5597975) ，产品可以抽象多个级别，依次需要使用这三种工厂

### 建造者模式
* 一个对象，若干个属性，可以一个一个设置属性

### 代理模式
* 一个接口，至少一个实现类，然后一个代理类也实现相同的接口
* 代理类里，调用常规的实现类的方法
* 举个例子：使用Hystix做HA时，外面封装一个统一方法；hystrix的fallback，相当于代理类中切换
 
### 责任链模式
* 即 链表结构；
* 对象之中，带一个指向下一级同类对象的引用。如果自己处理不了，或者不是自己的任务，就交给下一个。

### 迭代器模式
* 对一个集合进行封装，提供next()/hasNext() 这类接口，使得 外部可以直接遍历这个集合，而不用关系细节
* 例如Map的迭代，ResultSet的迭代

### 享元模式
* 内部封装一个池，
* 例如：相同参数进来的时候，不用创建新的对象，直接从池里取出来
 
### 合成模式/组合模式
* 一个对象内部，有一个若干同类对象的集合
* 例如：领导和开发，都是职员；领导管理若干个职员。

### 策略模式
* 一个类是实体，一个抽象类/接口是策略；
* 实体里调用策略完成功能；
* 调用不同策略，就是实现不同的同类功能

 

